#!/usr/bin/env python3
# scripts/generate_types.py

"""
TypeScript型定義自動生成スクリプト
FastAPIのPydanticモデルからTypeScript型定義を生成
"""

import asyncio
import json
import re
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime
import sys

# プロジェクトルートをPythonパスに追加
sys.path.append(str(Path(__file__).parent.parent))

from app.main import app
from fastapi.openapi.utils import get_openapi

class TypeScriptGenerator:
    """TypeScript型定義生成クラス"""
    
    def __init__(self):
        self.type_mapping = {
            "string": "string",
            "integer": "number", 
            "number": "number",
            "boolean": "boolean",
            "array": "Array",
            "object": "object",
            "null": "null"
        }
        
        self.generated_types = set()
        self.output_lines = []
    
    def generate_types(self, output_dir: Path) -> None:
        """TypeScript型定義生成メイン処理"""
        print("🚀 TypeScript型定義生成開始...")
        
        # OpenAPI スキーマ取得
        openapi_schema = get_openapi(
            title=app.title,
            version="1.0.0",
            description=app.description,
            routes=app.routes,
        )
        
        # ヘッダー追加
        self._add_header()
        
        # スキーマから型定義生成
        if "components" in openapi_schema and "schemas" in openapi_schema["components"]:
            schemas = openapi_schema["components"]["schemas"]
            
            for schema_name, schema_def in schemas.items():
                if schema_name not in self.generated_types:
                    self._generate_type_definition(schema_name, schema_def)
        
        # エンドポイント型定義生成
        self._generate_api_types(openapi_schema)
        
        # ファイル出力
        output_file = output_dir / "api-types.ts"
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, "w", encoding="utf-8") as f:
            f.write("\n".join(self.output_lines))
        
        print(f"✅ TypeScript型定義生成完了: {output_file}")
        print(f"   - 生成された型: {len(self.generated_types)}個")
    
    def _add_header(self) -> None:
        """ファイルヘッダー追加"""
        self.output_lines.extend([
            "// 🤖 This file is auto-generated by generate_types.py",
            f"// Generated at: {datetime.utcnow().isoformat()}Z",
            "// Do not edit this file directly",
            "",
            "// ============================================",
            "// Kaboom Stock Trading API - TypeScript Types",
            "// ============================================",
            ""
        ])
    
    def _generate_type_definition(self, name: str, schema: Dict[str, Any]) -> None:
        """単一型定義生成"""
        if name in self.generated_types:
            return
        
        self.generated_types.add(name)
        
        if schema.get("type") == "object":
            self._generate_interface(name, schema)
        elif "enum" in schema:
            self._generate_enum(name, schema)
        elif "anyOf" in schema or "oneOf" in schema:
            self._generate_union_type(name, schema)
        else:
            self._generate_type_alias(name, schema)
    
    def _generate_interface(self, name: str, schema: Dict[str, Any]) -> None:
        """インターフェース生成"""
        self.output_lines.extend([
            f"export interface {name} {{",
        ])
        
        properties = schema.get("properties", {})
        required = schema.get("required", [])
        
        for prop_name, prop_schema in properties.items():
            optional = "" if prop_name in required else "?"
            prop_type = self._get_typescript_type(prop_schema)
            
            # コメント追加
            if "description" in prop_schema:
                self.output_lines.append(f"  /** {prop_schema['description']} */")
            
            self.output_lines.append(f"  {prop_name}{optional}: {prop_type};")
        
        self.output_lines.extend([
            "}",
            ""
        ])
    
    def _generate_enum(self, name: str, schema: Dict[str, Any]) -> None:
        """列挙型生成"""
        enum_values = schema.get("enum", [])
        
        self.output_lines.extend([
            f"export enum {name} {{",
        ])
        
        for value in enum_values:
            # 文字列の場合
            if isinstance(value, str):
                # キャメルケースに変換
                key = self._to_pascal_case(value)
                self.output_lines.append(f"  {key} = '{value}',")
            else:
                self.output_lines.append(f"  {value} = {value},")
        
        self.output_lines.extend([
            "}",
            ""
        ])
    
    def _generate_union_type(self, name: str, schema: Dict[str, Any]) -> None:
        """ユニオン型生成"""
        union_schemas = schema.get("anyOf", schema.get("oneOf", []))
        union_types = []
        
        for union_schema in union_schemas:
            union_types.append(self._get_typescript_type(union_schema))
        
        self.output_lines.extend([
            f"export type {name} = {' | '.join(union_types)};",
            ""
        ])
    
    def _generate_type_alias(self, name: str, schema: Dict[str, Any]) -> None:
        """型エイリアス生成"""
        ts_type = self._get_typescript_type(schema)
        self.output_lines.extend([
            f"export type {name} = {ts_type};",
            ""
        ])
    
    def _get_typescript_type(self, schema: Dict[str, Any]) -> str:
        """TypeScript型文字列取得"""
        if "$ref" in schema:
            # 参照型
            ref_name = schema["$ref"].split("/")[-1]
            return ref_name
        
        schema_type = schema.get("type")
        
        if schema_type == "array":
            item_type = self._get_typescript_type(schema.get("items", {}))
            return f"{item_type}[]"
        
        elif schema_type == "object":
            if "additionalProperties" in schema:
                value_type = self._get_typescript_type(schema["additionalProperties"])
                return f"Record<string, {value_type}>"
            else:
                return "object"
        
        elif schema_type in self.type_mapping:
            return self.type_mapping[schema_type]
        
        elif "enum" in schema:
            # インライン列挙型
            enum_values = schema["enum"]
            if all(isinstance(v, str) for v in enum_values):
                return " | ".join(f"'{v}'" for v in enum_values)
            else:
                return " | ".join(str(v) for v in enum_values)
        
        elif "anyOf" in schema or "oneOf" in schema:
            union_schemas = schema.get("anyOf", schema.get("oneOf", []))
            union_types = [self._get_typescript_type(s) for s in union_schemas]
            return " | ".join(union_types)
        
        else:
            return "any"
    
    def _generate_api_types(self, openapi_schema: Dict[str, Any]) -> None:
        """API型定義生成"""
        self.output_lines.extend([
            "// ============================================",
            "// API Endpoint Types",
            "// ============================================",
            ""
        ])
        
        # APIクライアント基底型
        self.output_lines.extend([
            "export interface ApiResponse<T = any> {",
            "  data?: T;",
            "  error?: string;",
            "  message?: string;",
            "  timestamp?: string;",
            "}",
            "",
            "export interface PaginatedResponse<T = any> {",
            "  items: T[];",
            "  total: number;",
            "  page: number;",
            "  per_page: number;",
            "  pages: number;",
            "}",
            "",
            "export interface ApiError {",
            "  error: string;",
            "  status_code: number;",
            "  detail?: string;",
            "  timestamp?: string;",
            "}",
            ""
        ])
        
        # WebSocket型定義
        self._generate_websocket_types()
        
        # エンドポイント型定義
        paths = openapi_schema.get("paths", {})
        for path, methods in paths.items():
            for method, operation in methods.items():
                self._generate_endpoint_type(path, method, operation)
    
    def _generate_websocket_types(self) -> None:
        """WebSocket型定義生成"""
        self.output_lines.extend([
            "// ============================================",
            "// WebSocket Types",
            "// ============================================",
            "",
            "export interface WebSocketMessage<T = any> {",
            "  type: string;",
            "  data: T;",
            "  timestamp: string;",
            "}",
            "",
            "export interface PriceUpdateMessage {",
            "  symbol: string;",
            "  price: number;",
            "  change: number;",
            "  change_percent: number;",
            "  volume: number;",
            "  timestamp: string;",
            "}",
            "",
            "export interface OrderUpdateMessage {",
            "  order_id: string;",
            "  status: string;",
            "  symbol: string;",
            "  filled_quantity: number;",
            "  timestamp: string;",
            "}",
            "",
            "export interface AIAnalysisMessage {",
            "  symbol: string;",
            "  decision: 'buy' | 'sell' | 'hold';",
            "  confidence: number;",
            "  reasoning: string;",
            "  timestamp: string;",
            "}",
            ""
        ])
    
    def _generate_endpoint_type(self, path: str, method: str, operation: Dict[str, Any]) -> None:
        """エンドポイント型定義生成"""
        operation_id = operation.get("operationId")
        if not operation_id:
            return
        
        # レスポンス型生成
        responses = operation.get("responses", {})
        success_response = responses.get("200") or responses.get("201") or responses.get("204")
        
        if success_response and "content" in success_response:
            content = success_response["content"]
            if "application/json" in content:
                schema = content["application/json"].get("schema", {})
                response_type = self._get_typescript_type(schema)
                
                # エンドポイント情報をコメントとして追加
                self.output_lines.extend([
                    f"// {method.upper()} {path}",
                    f"export type {operation_id}Response = {response_type};",
                    ""
                ])
    
    def _to_pascal_case(self, snake_str: str) -> str:
        """スネークケースをパスカルケースに変換"""
        components = snake_str.split('_')
        return ''.join(word.capitalize() for word in components)

def main():
    """メイン処理"""
    # 出力ディレクトリ設定
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    
    # フロントエンドディレクトリが存在する場合はそこに出力
    web_types_dir = project_root / "web" / "types"
    if web_types_dir.parent.exists():
        output_dir = web_types_dir
    else:
        # 存在しない場合はAPIディレクトリ内に生成
        output_dir = project_root / "api" / "generated" / "types"
    
    try:
        # 型定義生成
        generator = TypeScriptGenerator()
        generator.generate_types(output_dir)
        
        # OpenAPI仕様書生成
        generate_openapi_spec(output_dir.parent / "openapi.json")
        
        print("🎉 フロントエンド統合準備完了！")
        
    except Exception as e:
        print(f"❌ エラーが発生しました: {e}")
        sys.exit(1)

def generate_openapi_spec(output_file: Path) -> None:
    """OpenAPI仕様書生成"""
    print("📝 OpenAPI仕様書生成中...")
    
    openapi_schema = get_openapi(
        title="Kaboom Stock Trading API",
        version="1.0.0",
        description="Real-time stock trading management system with AI analysis",
        routes=app.routes,
    )
    
    # サーバー情報追加
    openapi_schema["servers"] = [
        {
            "url": "http://localhost:8000",
            "description": "Development server"
        },
        {
            "url": "https://api.kaboom-trading.com",
            "description": "Production server"
        }
    ]
    
    # セキュリティスキーム追加
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT"
        }
    }
    
    # ファイル出力
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_file, "w", encoding="utf-8") as f:
        json.dump(openapi_schema, f, indent=2, ensure_ascii=False)
    
    print(f"✅ OpenAPI仕様書生成完了: {output_file}")

if __name__ == "__main__":
    main()