#!/usr/bin/env python3
# scripts/generate_types.py

"""
TypeScriptå‹å®šç¾©è‡ªå‹•ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
FastAPIã®Pydanticãƒ¢ãƒ‡ãƒ«ã‹ã‚‰TypeScriptå‹å®šç¾©ã‚’ç”Ÿæˆ
"""

import asyncio
import json
import re
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime
import sys

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’Pythonãƒ‘ã‚¹ã«è¿½åŠ 
sys.path.append(str(Path(__file__).parent.parent))

from app.main import app
from fastapi.openapi.utils import get_openapi

class TypeScriptGenerator:
    """TypeScriptå‹å®šç¾©ç”Ÿæˆã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.type_mapping = {
            "string": "string",
            "integer": "number", 
            "number": "number",
            "boolean": "boolean",
            "array": "Array",
            "object": "object",
            "null": "null"
        }
        
        self.generated_types = set()
        self.output_lines = []
    
    def generate_types(self, output_dir: Path) -> None:
        """TypeScriptå‹å®šç¾©ç”Ÿæˆãƒ¡ã‚¤ãƒ³å‡¦ç†"""
        print("ğŸš€ TypeScriptå‹å®šç¾©ç”Ÿæˆé–‹å§‹...")
        
        # OpenAPI ã‚¹ã‚­ãƒ¼ãƒå–å¾—
        openapi_schema = get_openapi(
            title=app.title,
            version="1.0.0",
            description=app.description,
            routes=app.routes,
        )
        
        # ãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ 
        self._add_header()
        
        # ã‚¹ã‚­ãƒ¼ãƒã‹ã‚‰å‹å®šç¾©ç”Ÿæˆ
        if "components" in openapi_schema and "schemas" in openapi_schema["components"]:
            schemas = openapi_schema["components"]["schemas"]
            
            for schema_name, schema_def in schemas.items():
                if schema_name not in self.generated_types:
                    self._generate_type_definition(schema_name, schema_def)
        
        # ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå‹å®šç¾©ç”Ÿæˆ
        self._generate_api_types(openapi_schema)
        
        # ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›
        output_file = output_dir / "api-types.ts"
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, "w", encoding="utf-8") as f:
            f.write("\n".join(self.output_lines))
        
        print(f"âœ… TypeScriptå‹å®šç¾©ç”Ÿæˆå®Œäº†: {output_file}")
        print(f"   - ç”Ÿæˆã•ã‚ŒãŸå‹: {len(self.generated_types)}å€‹")
    
    def _add_header(self) -> None:
        """ãƒ•ã‚¡ã‚¤ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ """
        self.output_lines.extend([
            "// ğŸ¤– This file is auto-generated by generate_types.py",
            f"// Generated at: {datetime.utcnow().isoformat()}Z",
            "// Do not edit this file directly",
            "",
            "// ============================================",
            "// Kaboom Stock Trading API - TypeScript Types",
            "// ============================================",
            ""
        ])
    
    def _generate_type_definition(self, name: str, schema: Dict[str, Any]) -> None:
        """å˜ä¸€å‹å®šç¾©ç”Ÿæˆ"""
        if name in self.generated_types:
            return
        
        self.generated_types.add(name)
        
        if schema.get("type") == "object":
            self._generate_interface(name, schema)
        elif "enum" in schema:
            self._generate_enum(name, schema)
        elif "anyOf" in schema or "oneOf" in schema:
            self._generate_union_type(name, schema)
        else:
            self._generate_type_alias(name, schema)
    
    def _generate_interface(self, name: str, schema: Dict[str, Any]) -> None:
        """ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ç”Ÿæˆ"""
        self.output_lines.extend([
            f"export interface {name} {{",
        ])
        
        properties = schema.get("properties", {})
        required = schema.get("required", [])
        
        for prop_name, prop_schema in properties.items():
            optional = "" if prop_name in required else "?"
            prop_type = self._get_typescript_type(prop_schema)
            
            # ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ 
            if "description" in prop_schema:
                self.output_lines.append(f"  /** {prop_schema['description']} */")
            
            self.output_lines.append(f"  {prop_name}{optional}: {prop_type};")
        
        self.output_lines.extend([
            "}",
            ""
        ])
    
    def _generate_enum(self, name: str, schema: Dict[str, Any]) -> None:
        """åˆ—æŒ™å‹ç”Ÿæˆ"""
        enum_values = schema.get("enum", [])
        
        self.output_lines.extend([
            f"export enum {name} {{",
        ])
        
        for value in enum_values:
            # æ–‡å­—åˆ—ã®å ´åˆ
            if isinstance(value, str):
                # ã‚­ãƒ£ãƒ¡ãƒ«ã‚±ãƒ¼ã‚¹ã«å¤‰æ›
                key = self._to_pascal_case(value)
                self.output_lines.append(f"  {key} = '{value}',")
            else:
                self.output_lines.append(f"  {value} = {value},")
        
        self.output_lines.extend([
            "}",
            ""
        ])
    
    def _generate_union_type(self, name: str, schema: Dict[str, Any]) -> None:
        """ãƒ¦ãƒ‹ã‚ªãƒ³å‹ç”Ÿæˆ"""
        union_schemas = schema.get("anyOf", schema.get("oneOf", []))
        union_types = []
        
        for union_schema in union_schemas:
            union_types.append(self._get_typescript_type(union_schema))
        
        self.output_lines.extend([
            f"export type {name} = {' | '.join(union_types)};",
            ""
        ])
    
    def _generate_type_alias(self, name: str, schema: Dict[str, Any]) -> None:
        """å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ç”Ÿæˆ"""
        ts_type = self._get_typescript_type(schema)
        self.output_lines.extend([
            f"export type {name} = {ts_type};",
            ""
        ])
    
    def _get_typescript_type(self, schema: Dict[str, Any]) -> str:
        """TypeScriptå‹æ–‡å­—åˆ—å–å¾—"""
        if "$ref" in schema:
            # å‚ç…§å‹
            ref_name = schema["$ref"].split("/")[-1]
            return ref_name
        
        schema_type = schema.get("type")
        
        if schema_type == "array":
            item_type = self._get_typescript_type(schema.get("items", {}))
            return f"{item_type}[]"
        
        elif schema_type == "object":
            if "additionalProperties" in schema:
                value_type = self._get_typescript_type(schema["additionalProperties"])
                return f"Record<string, {value_type}>"
            else:
                return "object"
        
        elif schema_type in self.type_mapping:
            return self.type_mapping[schema_type]
        
        elif "enum" in schema:
            # ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åˆ—æŒ™å‹
            enum_values = schema["enum"]
            if all(isinstance(v, str) for v in enum_values):
                return " | ".join(f"'{v}'" for v in enum_values)
            else:
                return " | ".join(str(v) for v in enum_values)
        
        elif "anyOf" in schema or "oneOf" in schema:
            union_schemas = schema.get("anyOf", schema.get("oneOf", []))
            union_types = [self._get_typescript_type(s) for s in union_schemas]
            return " | ".join(union_types)
        
        else:
            return "any"
    
    def _generate_api_types(self, openapi_schema: Dict[str, Any]) -> None:
        """APIå‹å®šç¾©ç”Ÿæˆ"""
        self.output_lines.extend([
            "// ============================================",
            "// API Endpoint Types",
            "// ============================================",
            ""
        ])
        
        # APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåŸºåº•å‹
        self.output_lines.extend([
            "export interface ApiResponse<T = any> {",
            "  data?: T;",
            "  error?: string;",
            "  message?: string;",
            "  timestamp?: string;",
            "}",
            "",
            "export interface PaginatedResponse<T = any> {",
            "  items: T[];",
            "  total: number;",
            "  page: number;",
            "  per_page: number;",
            "  pages: number;",
            "}",
            "",
            "export interface ApiError {",
            "  error: string;",
            "  status_code: number;",
            "  detail?: string;",
            "  timestamp?: string;",
            "}",
            ""
        ])
        
        # WebSocketå‹å®šç¾©
        self._generate_websocket_types()
        
        # ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå‹å®šç¾©
        paths = openapi_schema.get("paths", {})
        for path, methods in paths.items():
            for method, operation in methods.items():
                self._generate_endpoint_type(path, method, operation)
    
    def _generate_websocket_types(self) -> None:
        """WebSocketå‹å®šç¾©ç”Ÿæˆ"""
        self.output_lines.extend([
            "// ============================================",
            "// WebSocket Types",
            "// ============================================",
            "",
            "export interface WebSocketMessage<T = any> {",
            "  type: string;",
            "  data: T;",
            "  timestamp: string;",
            "}",
            "",
            "export interface PriceUpdateMessage {",
            "  symbol: string;",
            "  price: number;",
            "  change: number;",
            "  change_percent: number;",
            "  volume: number;",
            "  timestamp: string;",
            "}",
            "",
            "export interface OrderUpdateMessage {",
            "  order_id: string;",
            "  status: string;",
            "  symbol: string;",
            "  filled_quantity: number;",
            "  timestamp: string;",
            "}",
            "",
            "export interface AIAnalysisMessage {",
            "  symbol: string;",
            "  decision: 'buy' | 'sell' | 'hold';",
            "  confidence: number;",
            "  reasoning: string;",
            "  timestamp: string;",
            "}",
            ""
        ])
    
    def _generate_endpoint_type(self, path: str, method: str, operation: Dict[str, Any]) -> None:
        """ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå‹å®šç¾©ç”Ÿæˆ"""
        operation_id = operation.get("operationId")
        if not operation_id:
            return
        
        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹ç”Ÿæˆ
        responses = operation.get("responses", {})
        success_response = responses.get("200") or responses.get("201") or responses.get("204")
        
        if success_response and "content" in success_response:
            content = success_response["content"]
            if "application/json" in content:
                schema = content["application/json"].get("schema", {})
                response_type = self._get_typescript_type(schema)
                
                # ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæƒ…å ±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã¨ã—ã¦è¿½åŠ 
                self.output_lines.extend([
                    f"// {method.upper()} {path}",
                    f"export type {operation_id}Response = {response_type};",
                    ""
                ])
    
    def _to_pascal_case(self, snake_str: str) -> str:
        """ã‚¹ãƒãƒ¼ã‚¯ã‚±ãƒ¼ã‚¹ã‚’ãƒ‘ã‚¹ã‚«ãƒ«ã‚±ãƒ¼ã‚¹ã«å¤‰æ›"""
        components = snake_str.split('_')
        return ''.join(word.capitalize() for word in components)

def main():
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    # å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè¨­å®š
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    
    # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã“ã«å‡ºåŠ›
    web_types_dir = project_root / "web" / "types"
    if web_types_dir.parent.exists():
        output_dir = web_types_dir
    else:
        # å­˜åœ¨ã—ãªã„å ´åˆã¯APIãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã«ç”Ÿæˆ
        output_dir = project_root / "api" / "generated" / "types"
    
    try:
        # å‹å®šç¾©ç”Ÿæˆ
        generator = TypeScriptGenerator()
        generator.generate_types(output_dir)
        
        # OpenAPIä»•æ§˜æ›¸ç”Ÿæˆ
        generate_openapi_spec(output_dir.parent / "openapi.json")
        
        print("ğŸ‰ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰çµ±åˆæº–å‚™å®Œäº†ï¼")
        
    except Exception as e:
        print(f"âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        sys.exit(1)

def generate_openapi_spec(output_file: Path) -> None:
    """OpenAPIä»•æ§˜æ›¸ç”Ÿæˆ"""
    print("ğŸ“ OpenAPIä»•æ§˜æ›¸ç”Ÿæˆä¸­...")
    
    openapi_schema = get_openapi(
        title="Kaboom Stock Trading API",
        version="1.0.0",
        description="Real-time stock trading management system with AI analysis",
        routes=app.routes,
    )
    
    # ã‚µãƒ¼ãƒãƒ¼æƒ…å ±è¿½åŠ 
    openapi_schema["servers"] = [
        {
            "url": "http://localhost:8000",
            "description": "Development server"
        },
        {
            "url": "https://api.kaboom-trading.com",
            "description": "Production server"
        }
    ]
    
    # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ¼ãƒ è¿½åŠ 
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT"
        }
    }
    
    # ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_file, "w", encoding="utf-8") as f:
        json.dump(openapi_schema, f, indent=2, ensure_ascii=False)
    
    print(f"âœ… OpenAPIä»•æ§˜æ›¸ç”Ÿæˆå®Œäº†: {output_file}")

if __name__ == "__main__":
    main()